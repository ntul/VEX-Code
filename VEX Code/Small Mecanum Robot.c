#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    Expander,       sensorAnalog)
#pragma config(Sensor, dgtl1,  RightRearUltra, sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  RightFrontUltra, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  LeftFrontUltra,  sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  LeftRearUltra, sensorSONAR_cm)
#pragma config(Sensor, dgtl10, Limit,          sensorTouch)
#pragma config(Sensor, dgtl11, RightClaw,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, LeftClaw,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  RightFrontD,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightRearD,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  LeftRearD,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  LeftFrontD,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  RightL,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  LeftL,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RightBotFrontDrive, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RightTopFrontDrive, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           LeftTopFrontDrive, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port4,           LeftLift,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port5,           LeftBotFrontDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RightMidDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           RightRearDrive, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           LeftMidDrive,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LeftRearDrive, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Small Mecanum Methods.h"
#include "SmallBlueAuto.h"

/*
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

		//Declare count variable to keep track of our choice
	int count = 0;
	*/
void pre_auton() {

  SensorValue[RightClaw] = 0;
	SensorValue[LeftClaw] = 0;

/*

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
		string mainBattery, powerExpander;
		bLCDBacklight = true;									// Turn on LCD Backlight
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Red Autonomous");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 2;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Blue Autonomous");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
			case 2:


		// An infinite loop to keep the program running until you terminate it

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the battery voltage of a power exapnder
		displayLCDString(1, 0, "Expander: ");
		sprintf(powerExpander, "%1.2f%c", (float)SensorValue[in2]/275.0,'V'); //Build the value to be displayed
		displayNextLCDString(powerExpander);

		//Short delay for the LCD refresh rate

			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count=0;
			}
			else if(nLCDButtons== centerButton)
			{
				waitForRelease();
				count=0;
			}


			break;
		default:
			count = 0;
			break;



}
	}
	//------------- End of User Interface Code ---------------------


*/
}


task autonomous() {
/*		//------------- Beginning of Robot Movement Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Red autonomous");
		displayLCDCenteredString(1, "is running!");
		autoRed();
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Blue autonomous");
		displayLCDCenteredString(1, "is running!");
	  autoBlue();
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	//------------- End of Robot Movement Code -----------------------


*/

autoBlue();
//autoRed();
}


task usercontrol ()
{


	//Drive Controls
	int X2 = 0, Y1 = 0, X1 = 0;
	while (1 == 1)
	{
		if (abs(vexRT[Ch2]) > 30)
			Y1 = vexRT[Ch2];
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if (abs(vexRT[Ch1]) > 30)
			X1 = vexRT[Ch1];
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if (abs(vexRT[Ch4]) > 30)
			X2 = vexRT[Ch4];
		else
			X2 = 0;

		motor[RightTopFrontDrive] =  Y1 - X1 - X2;
		motor[RightBotFrontDrive] =  Y1 - X1 - X2;

		motor[RightRearDrive]     =  Y1 - X1 + X2;
		motor[RightMidDrive]      =  Y1 - X1 + X2;

		motor[LeftTopFrontDrive]  =  Y1 + X1 + X2;
		motor[LeftBotFrontDrive]  =  Y1 + X1 + X2;

		motor[LeftRearDrive]      =  Y1 + X1 - X2;
		motor[LeftMidDrive]       =  Y1 + X1 - X2;

		//Lift on Button 5
		if (vexRT[Btn5U] == 1) {
			liftUp();
		}
		else if (vexRT[Btn5D] == 1) {
			liftDown();
		}
		else {
			stopLift();
		}

		//Pneumatics LeftClaw

		if (vexRT[Btn8R] == 1)        // If button 7U pressed:
		{
			SensorValue[LeftClaw] = 1;
			//activate the solenoid for lock.
		}

		else if (vexRT[Btn8L] == 1)        // If button 7U pressed:
		{
			SensorValue[LeftClaw] = 0;
			//activate the solenoid for lock.
		}

		//Pneumatics RightClaw

		if (vexRT[Btn8U] == 1)        // If button 7U pressed:
		{
			SensorValue[RightClaw] = 1;
			//activate the solenoid for lock.
		}

		else if (vexRT[Btn8D] == 1) {
			SensorValue[RightClaw] = 0;
			// deactivate the solenoid for lock.
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
